---
toc: false
---

## Routing

Till now, we have built applications with a single page. However, most real-world applications consist of multiple pages or views that users can navigate between. This is where routing comes into play. A package called react router helps us implement routing in our React applications.

In Single Page Applications (SPAs), routing is handled on the client side. When a user navigates to a different page, the application dynamically updates the content without requiring a full page reload. This is achieved by using the History API to manipulate the browser's URL and render the appropriate components based on the current route.

## Setting Up React Router package

To get started with React Router, you'll need to install the `react-router-dom` package:

```bash
npm install react-router-dom
```

## Define Routes

Once you have React Router installed, you can define routes in your application. Depending on the router version, you can use either the `createBrowserRouter` function or the `<Routes>` and `<Route>` components to define your routes.

```jsx
import React from "react";
import { createBrowserRouter, RouterProvider } from "react-router-dom";

import Home from "./Home";
import About from "./About";
import Contact from "./Contact";
import Users from "./Users";
import UserDetail from "./UserDetail";

const router = createBrowserRouter([
  { path: "/", element: <Home /> },
  { path: "/about", element: <About /> },
  { path: "/contact", element: <Contact /> },
  { path: "/users", element: <Users /> },
  { path: "/users/:id", element: <UserDetail /> }, // Dynamic route example
]);

function App() {
  return <RouterProvider router={router} />;
}
```

A route that starts with a slash is an absolute route, while a route that does not start with a slash is a relative route. It becomes important when we have nested routes. When doing nested routes, we should use relative routes for child routes so that they get appended to the parent route correctly. To go one step back to the parent, we can use `..` in the relative route. By default, its resolved relative to the route definition path. We can change this behavior by using `relative="path"` or `relative="route"` props in the `Link` or `NavLink` components.

> [Stackblitz example](https://stackblitz.com/edit/vitejs-vite-198aqotr?file=src%2FApp.jsx)

## Alternate way to define routes (older versions)

Alternatively, you can define routes using the `<Routes>` and `<Route>` components within your main `App` component. Here's how you can do it:

```jsx
import React from "react";
import { createRoutesFromElements, Route } from "react-router-dom";
import Home from "./Home";
import About from "./About";
import Contact from "./Contact";

const routeDefs = createRoutesFromElements(
  <Route>
    <Route path="/" element={<Home />} />
    <Route path="/about" element={<About />} />
    <Route path="/contact" element={<Contact />} />
  </Route>,
);

const router = createBrowserRouter(routeDefs);

function App() {
  return <RouterProvider router={router} />;
}
```

## In App Navigation

To navigate between different routes in your application, you can use the `<Link>` component provided by React Router. The `<Link>` component allows you to create clickable links that change the URL and render the corresponding component without a full page reload. Here's an example of how to use the `<Link>` component for navigation:

```jsx
import { Link } from "react-router-dom";

function Navbar() {
  return (
    <nav>
      <ul>
        <li>
          <Link to="/">Home</Link>
        </li>
        <li>
          <Link to="/about">About</Link>
        </li>
        <li>
          <Link to="/contact">Contact</Link>
        </li>
      </ul>
    </nav>
  );
}
```

for Navigation, we can also use NavLink component. It is similar to Link but it adds styling attributes to the rendered element when it matches the current URL.

```jsx
import { NavLink } from "react-router-dom";

function Navbar() {
  return (
    <nav>
      <ul>
        <li>
          <NavLink
            to="/"
            className={({ isActive }) => (isActive ? "active" : "")}
          >
            Home
          </NavLink>
        </li>
      </ul>
    </nav>
  );
}
```

## Programmatic Navigation & Dynamic Routes

Sometimes, you may need to navigate to a different route programmatically, such as after a form submission or an API call. React Router provides the `useNavigate` hook for this purpose. Here's an example of how to use `useNavigate` for programmatic navigation:

```jsx
import { useNavigate, useParams } from "react-router-dom";

function MyComponent() {
  const navigate = useNavigate();
  const params = useParams();

  const handleSubmit = () => {
    // Perform some action (e.g., form submission)
    // Then navigate to a different route
    navigate("/about/" + params.id);
  };

  return <button onClick={handleSubmit}>Go to About Page</button>;
}
```

## Layouts

We can have some components that are common across multiple pages, such as a navigation bar or footer. To achieve this, we can create a layout component that wraps around our page components. Here's an example of how to implement layouts in React Router:

```jsx
// Have a Layout component
import { Outlet } from "react-router-dom";

function RootLayout() {
  return (
    <>
      <Navbar />
      <main>
        <Outlet />
      </main>
      <Footer />
    </>
  );
}

// and in route
const router = createBrowserRouter([
  {
    path: "/",
    element: <RootLayout />,
    children: [
      { index: true, element: <Home /> }, // Default or Index route
      { path: "about", element: <About /> },
      { path: "contact", element: <Contact /> },
    ],
  },
]);
```

## Error pages

We can define error pages to handle invalid routes or errors during navigation. React Router allows us to specify an `errorElement` for routes, which will be rendered when an error occurs. Here's an example of how to set up error pages in React Router:

```jsx
function ErrorPage() {
  return (
    <div>
      <h1>Oops!</h1>
      <p>Sorry, an unexpected error has occurred.</p>
    </div>
  );
}
```

and in the route definition:

```jsx
const router = createBrowserRouter([
  {
    path: "/",
    element: <RootLayout />,
    errorElement: <ErrorPage />,
    children: [
      { index: true, element: <Home /> }, // Default or Index route
      { path: "about", element: <About /> },
      { path: "contact", element: <Contact /> },
    ],
  },
]);
```

> [Stackblitz example](https://stackblitz.com/edit/vitejs-vite-bywgsykc?file=src%2FApp.jsx)

if we visit an undefined route, the ErrorPage component will be displayed. We can attach errorElement to any route to handle errors specific to that route.

## Loaders ( React router 6+)

We can fetch data before rendering a route using loaders. (Not after loading a component first, and then using useEffect to send API request). Loaders are functions that run before a route is rendered, allowing us to fetch data and pass it to the component as props. Here's an example of how to use loaders in React Router:

```jsx
async function userLoader({ params }) {
  const response = await fetch(`/api/users/${params.id}`);
  const user = await response.json();
  return { user };
}
```

and in the route definition:

```jsx
const router = createBrowserRouter([
  { path: "/users/:id", element: <UserDetail />, loader: userLoader },
]);
```

and in the UserDetail component, we can access the loaded data using the useLoaderData hook:

```jsx
import { useLoaderData } from "react-router-dom";

function UserDetail() {
  const { user } = useLoaderData();
  return (
    <div>
      <UserProfile user={user} />
    </div>
  );
}
```

> [Stackblitz example](https://stackblitz.com/edit/vitejs-vite-63drzc5a?file=src%2FApp.jsx)

Since this logic is not part of the component, it makes the component cleaner and easier to test.

We could also use the useLoaderData directly within the UserProfile component if needed. Even though its not a page component, we can still use the hook to access the loader data. We cannot access them at a higher level than the route component though. Any page component or its children can access the loader data. The loader can be moved to the page component too if we want to keep the data fetching logic closer to the component that uses it. Loaders will be executed when we are navigating to that route.

```jsx
function UserDetail() {
  // rest of the code
}

export default UserDetail;

export async function loader() {
  // loader code here
}

// In the route definition
import { loader as userDetailLoader } from "./UserDetail";

const router = createBrowserRouter([
  { path: "/users/:id", element: <UserDetail />, loader: userDetailLoader },
]);
```

What happens if the loader takes time to fetch the data? By default, the route will wait for the loader to complete before rendering the component. That is not a good user experience. We no longer need the loading states in the component though.

At the LayoutRoot, we can use the useNavigation hook to check if any navigation is in progress (including waiting for loaders). Based on that, we can show a loading indicator.

```jsx
function RootLayout() {
  const navigation = useNavigation();
  // idle | loading | submitting
  return (
    <>
      <Navbar />
      <main>
        {navigation.state === "loading" ? <LoadingSpinner /> : <Outlet />}
      </main>
      <Footer />
    </>
  );
}
```

> [Stackblitz example](https://stackblitz.com/edit/vitejs-vite-2ahkj7sv?file=src%2FApp.jsx)

## Return response from loader

Loaders can also return a Response object to set custom status codes or headers. This is useful for handling errors or redirects. Here's an example of how to return a Response from a loader:

```jsx
export async function loader() {
  //...logic
  const res = new Response(JSON.stringify({ user }), {
    status: 200,
    headers: {
      "Content-Type": "application/json",
    },
  });
  return res;
}
```

or

```jsx
export async function loader() {
  //...logic
  const response = await fetch("/api/user/1");
  return response;
}
```

when we do so, the router package will automatically parse the JSON response for us. In the component, we can access the data as usual using the useLoaderData hook.

```jsx
function UserDetail() {
  const { user } = useLoaderData(); // will automatically give the data part.
  //...
}
```

We no longer need to manually parse the JSON response in the loader or component. Note, we cannot use hooks like useFetch inside the loader since its not a React component. We have to use standard fetch or any other data fetching library that works outside React components.

> [Stackblitz example](https://stackblitz.com/edit/vitejs-vite-wqptulw4?file=src%2FApp.jsx)

## Error handling in loaders

Use these as the general thumb rule when deciding where to handle errors in loaders - either in the component or using ErrorBoundary (errorElement).

**Use ErrorBoundary (ErrorPage) for:**

- Network failures, 404s, server errors
- Unexpected/unrecoverable errors
- Cleaner separation of concerns

**Handle in component for:**

- Expected error states you want to show inline (e.g., "User not found" message within the page layout)
- Partial errors where rest of UI should still render
- Custom error UI that needs to match your page design

**Key difference: **ErrorBoundary replaces the entire route component. In-component handling lets you control exactly what shows and keep navigation/layout intact.

Scenario 1: We return a custom object indicating an error

```jsx
export async function userLoader({ params }) {
  await new Promise((resolve) => setTimeout(resolve, 500));

  try {
    const response = await fetch(
      `https://jsonplaceholder.typicode.com/users/${params.id}`,
    );

    if (!response.ok) {
      return { isError: true, message: "Failed to fetch user data" };
    }

    const user = await response.json();
    return { user };
  } catch (error) {
    return { isError: true, message: "Network error occurred" };
  }
}
```

and in component, we can handle the error and success cases separately.

```jsx
import { Link, useLoaderData, useNavigate } from 'react-router-dom';

function UserDetail() {
  const data = useLoaderData();
  const navigate = useNavigate();

  // Handle error returned from loader
  if (data.isError) {
    return (
      ...
    );
  }

  const { user } = data;

  return (
    ...
  );
}

export default UserDetail;

```

> [Stackblitz example for Error handling within component when custom object is returned](https://stackblitz.com/edit/vitejs-vite-rwccbh8j?file=src%2Floaders%2FuserLoader.js)

Now, instead of returning a `custom object`, we can also throw an error. This will trigger the errorElement defined in the route.

If you throw in the loader, React Router will:

- Catch the error and render your errorElement component (if you have one defined in your route)
- Stop rendering the route component entirely
- Pass the error to useRouteError() hook in your ErrorBoundary

```jsx
export async function userLoader({ params }) {
  await new Promise((resolve) => setTimeout(resolve, 500));

  try {
    const response = await fetch(
      `https://jsonplaceholder.typicode.com/users/${params.id}`,
    );

    if (!response.ok) {
      throw new Error("Failed to fetch user data. Try after sometime");
    }

    const user = await response.json();

    return { user };
  } catch (error) {
    throw new Error("Failed to fetch user data. Try after sometime");
  }
}
```

and in the ErrorPage component, use the useRouteError hook to access the error details.

```jsx
function ErrorPage() {
  const error = useRouteError();
  return (
    <div>
      <h1>Oops!</h1>
      <p>Sorry, an unexpected error has occurred.</p>
      <p>{error.message}</p>
    </div>
  );
}
```

> [Stackblitz example for Error handling using errorElement when error is thrown](https://stackblitz.com/edit/vitejs-vite-scpxhzdm?file=src%2Floaders%2FuserLoader.js)

## Access data from other routes

We can access data loaded by parent routes using the useRouteLoaderData hook. This is useful when we have some common data that needs to be shared across multiple routes. Here's an example of how to access data from other routes:

Our loader looks like this

```jsx
export async function usersLoader() {
  await new Promise((resolve) => setTimeout(resolve, 1000));

  try {
    const response = await fetch("https://jsonplaceholder.typicode.com/users");

    if (!response.ok) {
      return {
        isError: true,
        message: "Failed to load users",
      };
    }

    const users = await response.json();
    return { users };
  } catch (error) {
    return { isError: true, message: "Network error occurred" };
  }
}
```

and we connect the loader to the Layout route instead of the Users route.

```jsx
const router = createBrowserRouter([
  {
    element: <Layout />,
    path: "/",
    id: "root",
    loader: usersLoader,
    errorElement: <ErrorPage />,
    children: [
      { path: "/", element: <Home /> },
      {
        path: "/users",
        element: <Users />,
        errorElement: <ErrorPage />,
      },
    ],
  },
]);
```

Now, the Users component, which is a child route of the Layout route, can access the loader data using the useRouteLoaderData hook.

```jsx
import { Link, useLoaderData, useRouteLoaderData } from 'react-router-dom';

function Users() {
  const data = useRouteLoaderData('root');

  if (data.isError) {
    return (
      ...
    );
  }

  const { users } = data;
}
```

> [Stackblitz example for using useRouteLoaderData](https://stackblitz.com/edit/vitejs-vite-xkc7ih3b?file=src%2Floaders%2FuserLoader.js)

Key difference:

- useLoaderData() - gets data from current route or closest parent
- useRouteLoaderData('id') - gets data from specific route by ID (must be parent/ancestor)

Neither can access sibling route data.

## Data submission

Just like we have loaders to load data, we have actions to send data. For that, create a new action function:

```jsx
// contactAction.js
export async function contactAction({ request }) {
  const formData = await request.formData();

  const data = {
    name: formData.get("name"),
    email: formData.get("email"),
    message: formData.get("message"),
  };

  // Simulate API call
  await new Promise((resolve) => setTimeout(resolve, 1000));

  // Simulate sending to an API
  console.log("Submitting:", data);

  // Return success response
  return {
    success: true,
    message: "Message sent successfully!",
  };
}
```

and attach the same to the route:

```jsx
 { path: '/contact',
   element: <Contact />,
   action: contactAction
 },
```

and in the Contact component, we can use the special Form component from react-router-dom instead of the regular form element.

```jsx
import React from 'react';
import { Link, Form, useActionData, useNavigation } from 'react-router-dom';

function Contact() {
  const actionData = useActionData(); // Get response from action
  const navigation = useNavigation(); // Get submission state

  const isSubmitting = navigation.state === 'submitting';

  return (
    <div>
      <div className="container">
        <div>
          <div className="card-body p-4 text-white">
            {actionData?.success && (
              ...
            )}

            {/* Use Form instead of form */}
            <Form method="post">
             ...
              <button
                type="submit"
                disabled={isSubmitting}
              >
                {isSubmitting ? 'Sending...' : 'Send Message'}
              </button>
            </Form>
          </div>
        </div>
      </div>
    </div>
  );
}

export default Contact;

```

> [Stackblitz example for data submission using actions](https://stackblitz.com/edit/vitejs-vite-crrxepvt?file=src%2FApp.jsx)

To submit data programmatically, we can use the useSubmit hook.

```jsx
import { useSubmit } from "react-router-dom";

function Contact() {
  const submit = useSubmit();

  const handleManualSubmit = () => {
    const formData = new FormData();
    formData.append("name", "John Doe");
    formData.append("email", "john@example.com");
    formData.append("message", "Hello!");

    submit(formData, { method: "post" });
  };

  return (
    <div>
      <button onClick={handleManualSubmit}>Submit Programmatically</button>
    </div>
  );
}
```

> [Stackblitz example for programmatic submission using useSubmit](https://stackblitz.com/edit/vitejs-vite-ek7pbmmu?file=src%2FApp.jsx)

to update the UI state based on the submission status, we can use the useNavigation hook as we have seen before.

## Output validation errors

We can return validation errors from the action function and display them in the component. Here's an example of how to handle validation errors:

In the action function, we can validate the form data and return errors if any.

```jsx
// contactAction.js
export async function contactAction({ request }) {
  const formData = await request.formData();

  const data = {
    name: formData.get("name"),
    email: formData.get("email"),
    message: formData.get("message"),
  };

  // Client-side validation
  const errors = [];

  if (!data.name || data.name.trim().length < 2) {
    errors.push("Name must be at least 2 characters long");
  }

  if (!data.email || !data.email.includes("@")) {
    errors.push("Please provide a valid email address");
  }

  if (!data.message || data.message.trim().length < 10) {
    errors.push("Message must be at least 10 characters long");
  }

  // Return errors if validation fails
  if (errors.length > 0) {
    return { errors, status: 422 };
  }

  // Simulate API call
  await new Promise((resolve) => setTimeout(resolve, 1000));

  console.log("Submitting:", data);

  return {
    success: true,
    message: "Message sent successfully!",
  };
}
```

and within the Contact component, we can display the validation errors returned from the action.

```jsx
import React from "react";
import { Link, Form, useActionData, useNavigation } from "react-router-dom";

function Contact() {
  const actionData = useActionData();
  const navigation = useNavigation();

  const isSubmitting = navigation.state === "submitting";

  return (
    <div>
      <div>
        <div>
          <div className="card-body p-4 text-white">
            <h3 className="mb-3">üìß Contact Page</h3>

            {/* Show success message */}
            {actionData?.success && <div>{actionData.message}</div>}

            {/* Show validation errors */}
            {actionData?.errors && actionData.errors.length > 0 && (
              <div>
                <strong>Please fix the following errors:</strong>
                <ul>
                  {actionData.errors.map((error, index) => (
                    <li key={index}>{error}</li>
                  ))}
                </ul>
              </div>
            )}

            <Form method="post">...</Form>
          </div>
        </div>
      </div>
    </div>
  );
}

export default Contact;
```

> [Stackblitz example for validation errors](https://stackblitz.com/edit/vitejs-vite-7ivhn6q2?file=src%2Factions%2FcontactAction.js)

## Reuse actions

We can reuse action functions across multiple routes. This is useful when we have similar forms or data submission requirements in different parts of our application. Here's an example of how to do that.

- Check the contactAction function and see how its made reusable.
- We can attach the same action to multiple routes.
- In the component, we can use the same Form component to submit data to different routes.

> [Stackblitz example for reusing actions](https://stackblitz.com/edit/vitejs-vite-rekhh2fn?file=src%2Factions%2FcontactAction.js)

## Using useFetcher for non-route components

The `useFetcher` hook allows us to perform data loading and submission in components that are not directly tied to a route. This is useful for components like modals or sidebars that need to fetch or submit data without changing the current route. Here's an example of how to use `useFetcher`:

Common scenarios:

1. Newsletter signup in footer (appears on every page):
2. Add to cart button in product listing (doesn't navigate away)
3. Like/Upvote button on posts (inline action without navigation)
4. Delete item button in a list (removes item without leaving page)
5. Load data in a modal without route change
6. Search autocomplete (load results without navigation):

In the below example, we have a NewsletterSignup component that uses `useFetcher` to submit the signup form without navigating away from the current page.

- we added a newsletterAction function to handle the form submission.
- In the NewsletterSignup component, we use the `useFetcher` hook to create a fetcher object.
- The fetcher.Form component is used to create a form that submits data to the newsletterAction without changing the route.
- We can access the submission state and response data using the fetcher object.

> [Stackblitz example for using useFetcher](https://stackblitz.com/edit/vitejs-vite-fnzp6kuq?file=src%2FApp.jsx)

## Defer data fecthing with defer() (React Router 6.4+, Deprecated in V7)

We can defer the loading of certain data until after the component has rendered using the `defer` function. This allows us to prioritize critical data and improve the perceived performance of our application. Here's an example of how to use `defer` in a loader:

- In the loader function, we can use the `defer` function to specify which data should be loaded immediately and which data can be deferred.
- Note that defer is deprecated in React Router v7.

```jsx

export async function userLoader({ params }) {
  await new Promise((resolve) => setTimeout(resolve, 500));

  // Critical data - await it (loads first)
  const userPromise = fetch(
    `https://jsonplaceholder.typicode.com/users/${params.id}`
  ).then(async (response) => {
    ...
  });

  // Non-critical data - defer it (loads in background)
  const postsPromise = fetch(
    `https://jsonplaceholder.typicode.com/users/${params.id}/posts`
  ).then((response) => {
    ...
  });

  // Await critical data, defer non-critical
  return defer({
    user: await userPromise, // User loads first
    posts: postsPromise, // Posts load in background
  });
}
```

and in the component, we can use the `Suspense` and `Await` components to handle the deferred data.

```jsx
// UserDetail.jsx
import React, { Suspense } from "react";
import { Link, useLoaderData, useNavigate, Await } from "react-router-dom";

function UserDetail() {
  const { user, posts } = useLoaderData();
  const navigate = useNavigate();

  // Handle error for critical data (user)
  if (user.message) {
    return (
      ...
    );
  }

  return (
    <div>
      <div className="container">
        <div>
          <div className="card-body p-4 text-white">

            {/* Critical data - shows immediately */}
            <div className="mb-4">
              <div>
                {user.name.charAt(0).toUpperCase()}
              </div>
            </div>

            {/* Deferred data - loads in background */}
            <div>
              <Suspense fallback={<div>Loading posts...</div>}>
                <Await
                  resolve={posts}
                  errorElement={
                    <div
                      className="text-danger"
                      style={{ fontSize: "0.85rem" }}
                    >
                      ‚ö†Ô∏è Failed to load posts
                    </div>
                  }
                >
                  {(loadedPosts) => (
                    <div style={{ fontSize: "0.85rem" }}>..</div>
                  )}
                </Await>
              </Suspense>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

export default UserDetail;
```

> [Stackblitz example for using defer](https://stackblitz.com/edit/vitejs-vite-8ygvsxjf?file=src%2Floaders%2FuserLoader.js)

This way, the critical user data is loaded and displayed immediately, while the non-critical posts data is loaded in the background without blocking the initial render.
